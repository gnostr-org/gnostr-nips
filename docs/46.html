<h1>NIP-46</h1>
<h2>Nostr Remote Signing</h2>
<h2>Changes</h2>
<p><code>remote-signer-key</code> is introduced, passed in bunker url, clients must differentiate between <code>remote-signer-pubkey</code> and <code>user-pubkey</code>, must call <code>get_public_key</code> after connect, nip05 login is removed, create_account moved to another NIP.</p>
<h2>Rationale</h2>
<p>Private keys should be exposed to as few systems - apps, operating systems, devices - as possible as each system adds to the attack surface.</p>
<p>This NIP describes a method for 2-way communication between a remote signer and a Nostr client. The remote signer could be, for example, a hardware device dedicated to signing Nostr events, while the client is a normal Nostr client.</p>
<h2>Terminology</h2>
<ul>
<li><strong>user</strong>: A person that is trying to use Nostr.</li>
<li><strong>client</strong>: A user-facing application that <em>user</em> is looking at and clicking buttons in. This application will send requests to <em>remote-signer</em>.</li>
<li><strong>remote-signer</strong>: A daemon or server running somewhere that will answer requests from <em>client</em>, also known as "bunker".</li>
<li><strong>client-keypair/pubkey</strong>: The keys generated by <em>client</em>. Used to encrypt content and communicate with <em>remote-signer</em>.</li>
<li><strong>remote-signer-keypair/pubkey</strong>: The keys used by <em>remote-signer</em> to encrypt content and communicate with <em>client</em>. This keypair MAY be same as <em>user-keypair</em>, but not necessarily.</li>
<li><strong>user-keypair/pubkey</strong>: The actual keys representing <em>user</em> (that will be used to sign events in response to <code>sign_event</code> requests, for example). The <em>remote-signer</em> generally has control over these keys.</li>
</ul>
<p>All pubkeys specified in this NIP are in hex format.</p>
<h2>Overview</h2>
<ol>
<li><em>client</em> generates <code>client-keypair</code>. This keypair doesn't need to be communicated to <em>user</em> since it's largely disposable. <em>client</em> might choose to store it locally and they should delete it on logout;</li>
<li>A connection is established (see below), <em>remote-signer</em> learns <code>client-pubkey</code>, <em>client</em> learns <code>remote-signer-pubkey</code>.</li>
<li><em>client</em> uses <code>client-keypair</code> to send requests to <em>remote-signer</em> by <code>p</code>-tagging and encrypting to <code>remote-signer-pubkey</code>;</li>
<li><em>remote-signer</em> responds to <em>client</em> by <code>p</code>-tagging and encrypting to the <code>client-pubkey</code>.</li>
<li><em>client</em> requests <code>get_public_key</code> to learn <code>user-pubkey</code>.</li>
</ol>
<h2>Initiating a connection</h2>
<p>There are two ways to initiate a connection:</p>
<h3>Direct connection initiated by <em>remote-signer</em></h3>
<p><em>remote-signer</em> provides connection token in the form:</p>
<pre><code>bunker://&lt;remote-signer-pubkey&gt;?relay=&lt;wss://relay-to-connect-on&gt;&amp;relay=&lt;wss://another-relay-to-connect-on&gt;&amp;secret=&lt;optional-secret-value&gt;
</code></pre>
<p><em>user</em> passes this token to <em>client</em>, which then sends <code>connect</code> request to <em>remote-signer</em> via the specified relays. Optional secret can be used for single successfully established connection only, <em>remote-signer</em> SHOULD ignore new attempts to establish connection with old secret.</p>
<h3>Direct connection initiated by the <em>client</em></h3>
<p><em>client</em> provides a connection token using <code>nostrconnect://</code> as the protocol, and <code>client-pubkey</code> as the origin. Additional information should be passed as query parameters:</p>
<ul>
<li><code>relay</code> (required) - one or more relay urls on which the <em>client</em> is listening for responses from the <em>remote-signer</em>.</li>
<li><code>secret</code> (required) - a short random string that the <em>remote-signer</em> should return as the <code>result</code> field of its response.</li>
<li><code>perms</code> (optional) - a comma-separated list of permissions the <em>client</em> is requesting be approved by the <em>remote-signer</em></li>
<li><code>name</code> (optional) - the name of the <em>client</em> application</li>
<li><code>url</code> (optional) - the canonical url of the <em>client</em> application</li>
<li><code>image</code> (optional) - a small image representing the <em>client</em> application</li>
</ul>
<p>Here's an example:</p>
<pre><code>nostrconnect://83f3b2ae6aa368e8275397b9c26cf550101d63ebaab900d19dd4a4429f5ad8f5?relay=wss%3A%2F%2Frelay1.example.com&amp;perms=nip44_encrypt%2Cnip44_decrypt%2Csign_event%3A13%2Csign_event%3A14%2Csign_event%3A1059&amp;name=My+Client&amp;secret=0s8j2djs&amp;relay=wss%3A%2F%2Frelay2.example2.com
</code></pre>
<p><em>user</em> passes this token to <em>remote-signer</em>, which then sends <code>connect</code> <em>response</em> event to the <code>client-pubkey</code> via the specified relays. Client discovers <code>remote-signer-pubkey</code> from connect response author. <code>secret</code> value MUST be provided to avoid connection spoofing, <em>client</em> MUST validate the <code>secret</code> returned by <code>connect</code> response.</p>
<h2>Request Events <code>kind: 24133</code></h2>
<pre><code class="language-jsonc">{
    "kind": 24133,
    "pubkey": &lt;local_keypair_pubkey&gt;,
    "content": &lt;nip44(&lt;request&gt;)&gt;,
    "tags": [["p", &lt;remote-signer-pubkey&gt;]],
}
</code></pre>
<p>The <code>content</code> field is a JSON-RPC-like message that is <a href="44.md">NIP-44</a> encrypted and has the following structure:</p>
<pre><code class="language-jsonc">{
    "id": &lt;random_string&gt;,
    "method": &lt;method_name&gt;,
    "params": [array_of_strings]
}
</code></pre>
<ul>
<li><code>id</code> is a random string that is a request ID. This same ID will be sent back in the response payload.</li>
<li><code>method</code> is the name of the method/command (detailed below).</li>
<li><code>params</code> is a positional array of string parameters.</li>
</ul>
<h3>Methods/Commands</h3>
<p>Each of the following are methods that the <em>client</em> sends to the <em>remote-signer</em>.</p>
<table><thead><tr><th>Command</th><th>Params</th><th>Result</th></tr></thead><tbody>
<tr><td><code>connect</code></td><td><code>[&lt;remote-signer-pubkey&gt;, &lt;optional_secret&gt;, &lt;optional_requested_permissions&gt;]</code></td><td>"ack" OR <code>&lt;required-secret-value&gt;</code></td></tr>
<tr><td><code>sign_event</code></td><td><code>[&lt;{kind, content, tags, created_at}&gt;]</code></td><td><code>json_stringified(&lt;signed_event&gt;)</code></td></tr>
<tr><td><code>ping</code></td><td><code>[]</code></td><td>"pong"</td></tr>
<tr><td><code>get_public_key</code></td><td><code>[]</code></td><td><code>&lt;user-pubkey&gt;</code></td></tr>
<tr><td><code>nip04_encrypt</code></td><td><code>[&lt;third_party_pubkey&gt;, &lt;plaintext_to_encrypt&gt;]</code></td><td><code>&lt;nip04_ciphertext&gt;</code></td></tr>
<tr><td><code>nip04_decrypt</code></td><td><code>[&lt;third_party_pubkey&gt;, &lt;nip04_ciphertext_to_decrypt&gt;]</code></td><td><code>&lt;plaintext&gt;</code></td></tr>
<tr><td><code>nip44_encrypt</code></td><td><code>[&lt;third_party_pubkey&gt;, &lt;plaintext_to_encrypt&gt;]</code></td><td><code>&lt;nip44_ciphertext&gt;</code></td></tr>
<tr><td><code>nip44_decrypt</code></td><td><code>[&lt;third_party_pubkey&gt;, &lt;nip44_ciphertext_to_decrypt&gt;]</code></td><td><code>&lt;plaintext&gt;</code></td></tr>
</tbody></table>
<h3>Requested permissions</h3>
<p>The <code>connect</code> method may be provided with <code>optional_requested_permissions</code> for user convenience. The permissions are a comma-separated list of <code>method[:params]</code>, i.e. <code>nip44_encrypt,sign_event:4</code> meaning permissions to call <code>nip44_encrypt</code> and to call <code>sign_event</code> with <code>kind:4</code>. Optional parameter for <code>sign_event</code> is the kind number, parameters for other methods are to be defined later. Same permission format may be used for <code>perms</code> field of <code>metadata</code> in <code>nostrconnect://</code> string.</p>
<h2>Response Events <code>kind:24133</code></h2>
<pre><code class="language-json">{
    "id": &lt;id&gt;,
    "kind": 24133,
    "pubkey": &lt;remote-signer-pubkey&gt;,
    "content": &lt;nip44(&lt;response&gt;)&gt;,
    "tags": [["p", &lt;client-pubkey&gt;]],
    "created_at": &lt;unix timestamp in seconds&gt;
}
</code></pre>
<p>The <code>content</code> field is a JSON-RPC-like message that is <a href="44.md">NIP-44</a> encrypted and has the following structure:</p>
<pre><code class="language-json">{
    "id": &lt;request_id&gt;,
    "result": &lt;results_string&gt;,
    "error": &lt;optional_error_string&gt;
}
</code></pre>
<ul>
<li><code>id</code> is the request ID that this response is for.</li>
<li><code>results</code> is a string of the result of the call (this can be either a string or a JSON stringified object)</li>
<li><code>error</code>, <em>optionally</em>, it is an error in string form, if any. Its presence indicates an error with the request.</li>
</ul>
<h2>Example flow for signing an event</h2>
<ul>
<li><code>remote-signer-pubkey</code> is <code>fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52</code></li>
<li><code>user-pubkey</code> is also <code>fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52</code></li>
<li><code>client-pubkey</code> is <code>eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86</code></li>
</ul>
<h3>Signature request</h3>
<pre><code class="language-jsonc">{
    "kind": 24133,
    "pubkey": "eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86",
    "content": nip44({
        "id": &lt;random_string&gt;,
        "method": "sign_event",
        "params": [json_stringified(&lt;{
            content: "Hello, I'm signing remotely",
            kind: 1,
            tags: [],
            created_at: 1714078911
        }&gt;)]
    }),
    "tags": [["p", "fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52"]], // p-tags the remote-signer-pubkey
}
</code></pre>
<h3>Response event</h3>
<pre><code class="language-jsonc">{
    "kind": 24133,
    "pubkey": "fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52",
    "content": nip44({
        "id": &lt;random_string&gt;,
        "result": json_stringified(&lt;signed-event&gt;)
    }),
    "tags": [["p", "eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86"]], // p-tags the client-pubkey
}
</code></pre>
<h3>Diagram</h3>
<p><img src="https://i.nostr.build/P3gW.png" alt="signing-example" /></p>
<h2>Auth Challenges</h2>
<p>An Auth Challenge is a response that a <em>remote-signer</em> can send back when it needs the <em>user</em> to authenticate via other means. The response <code>content</code> object will take the following form:</p>
<pre><code class="language-json">{
    "id": &lt;request_id&gt;,
    "result": "auth_url",
    "error": &lt;URL_to_display_to_end_user&gt;
}
</code></pre>
<p><em>client</em> should display (in a popup or new tab) the URL from the <code>error</code> field and then subscribe/listen for another response from the <em>remote-signer</em> (reusing the same request ID). This event will be sent once the user authenticates in the other window (or will never arrive if the user doesn't authenticate).</p>
<h3>Example event signing request with auth challenge</h3>
<p><img src="https://i.nostr.build/W3aj.png" alt="signing-example-with-auth-challenge" /></p>
<h2>Appendix</h2>
<h3>Announcing <em>remote-signer</em> metadata</h3>
<p><em>remote-signer</em> MAY publish it's metadata by using <a href="05.md">NIP-05</a> and <a href="89.md">NIP-89</a>. With NIP-05, a request to <code>&lt;remote-signer&gt;/.well-known/nostr.json?name=_</code> MAY return this:</p>
<pre><code class="language-jsonc">{
    "names":{
        "_": &lt;remote-signer-app-pubkey&gt;,
    },
    "nip46": {
        "relays": ["wss://relay1","wss://relay2"...],
        "nostrconnect_url": "https://remote-signer-domain.example/&lt;nostrconnect&gt;"
    }
}
</code></pre>
<p>The <code>&lt;remote-signer-app-pubkey&gt;</code> MAY be used to verify the domain from <em>remote-signer</em>'s NIP-89 event (see below). <code>relays</code> SHOULD be used to construct a more precise <code>nostrconnect://</code> string for the specific <code>remote-signer</code>. <code>nostrconnect_url</code> template MAY be used to redirect users to <em>remote-signer</em>'s connection flow by replacing <code>&lt;nostrconnect&gt;</code> placeholder with an actual <code>nostrconnect://</code> string.</p>
<h3>Remote signer discovery via NIP-89</h3>
<p><em>remote-signer</em> MAY publish a NIP-89 <code>kind: 31990</code> event with <code>k</code> tag of <code>24133</code>, which MAY also include one or more <code>relay</code> tags and MAY include <code>nostrconnect_url</code> tag. The semantics of <code>relay</code> and <code>nostrconnect_url</code> tags are the same as in the section above.</p>
<p><em>client</em> MAY improve UX by discovering <em>remote-signers</em> using their <code>kind: 31990</code> events. <em>client</em> MAY then pre-generate <code>nostrconnect://</code> strings for the <em>remote-signers</em>, and SHOULD in that case verify that <code>kind: 31990</code> event's author is mentioned in signer's <code>nostr.json?name=_</code> file as <code>&lt;remote-signer-app-pubkey&gt;</code>.</p>
